---
title: "Sorting Unsigned Integers Faster in Java"
layout: post
theme: jekyll-theme-slate
date: 2017-06-30
---
I discovered a curious [resource](http://panthema.net/2013/sound-of-sorting/#video) for audio-visualising sort algorithms, which is exciting for two reasons. The first is that I finally feel like I understand Alexander Scriabin: he was not a composer. He discovered Tim Sort 80 years before Tim Peters and called it Black Mass. (If you aren't familiar with the piece, fast-forward to 1:40 to hear the congruence.)

<iframe width="560" height="315" src="https://www.youtube.com/embed/qj1luIOQHLw" frameborder="0" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/NVIjHj-lrT4" frameborder="0" allowfullscreen></iframe>


The second reason was that I noticed [Radix Sort (LSD)](https://www.youtube.com/watch?v=LyRWppObda4). While it was an affront to my senses, it used a mere 800 array accesses and _no comparisons_! I was unaware of this algorithm so delved deeper and implemented it for integers, and benchmarked my code against `Arrays.sort`. 

#### Radix Sort

It is taken as given by many (myself included, or am I just projecting my thoughts on to others?) that $latex O(n \log n)$ is the best you can do in a sort algorithm. But this is actually only true for sort algorithms which depend on comparison. If you can afford to restrict the data types your sort algorithm supports to types with a positional interpretation (`java.util` can't because it needs to be ubiquitous and maintainable), you can get away with a linear time algorithm.

Radix sort, along with the closely related [counting sort](https://en.wikipedia.org/wiki/Counting_sort), does not use comparisons. Instead, the data is interpreted as a fixed length string of symbols. For each position, the cumulative histogram of symbols is computed to calculate sort indices. While the data needs to be scanned several times, the algorithm scales linearly and the overhead of the multiple scans is amortised for large arrays. 

As you can see on [Wikipedia](https://en.wikipedia.org/wiki/Radix_sort), there are two kinds of radix sort: _Least Significant Digit_ and _Most Significant Digit_. This dichotomy relates to the order the (representational) string of symbols is traversed in. I implemented and benchmarked the LSD version for integers.

#### Implementation

The implementation interprets an integer as the concatenation of n bit string symbols of fixed size size 32/n. It performs n passes over the array, starting with the least significant bits, which it modifies in place. For each pass the data is scanned three times, in order to:

1. Compute the cumulative histogram over the symbols in their natural sort order.
2. Copy the value with symbol k to the mth position in a buffer, where m is defined by the cumulative density of k.
3. Copy the buffer back into the original array.

The implementation, which won't work unless the chunks are proper divisors of 32, is below. The bonus (or caveat) is that it automatically supports unsigned integers. The code could be modified slightly to work with signed integers at a performance cost.

```java
import java.util.Arrays;

public class RadixSort {

    private final int radix;

    public RadixSort() {
        this(Byte.SIZE);
    }

    public RadixSort(int radix) {
        assert 32 % radix== 0;
        this.radix= radix;
    }

    public void sort(int[] data) {
        int[] histogram = new int[(1 << radix) + 1];
        int shift = 0;
        int mask = (1 << radix) - 1;
        int[] copy = new int[data.length];
        while (shift < Integer.SIZE) {
            Arrays.fill(histogram, 0);
            for (int i = 0; i < data.length; ++i) {
                ++histogram[((data[i] & mask) >> shift) + 1];
            }
            for (int i = 0; i < 1 << radix; ++i) {
                histogram[i + 1] += histogram[i];
            }
            for (int i = 0; i < data.length; ++i) {
                copy[histogram[(data[i] & mask) >> shift]++] = data[i];
            }
            for (int i = 0; i < data.length; ++i) {
                data[i] = copy[i];
            }
            shift += radix;
            mask <<= radix;
        }
    }
}
```

The time complexity is obviously linear, a temporary buffer <em>is</em> allocated, but in comparison to `Arrays.sort` it looks fairly spartan. Instinctively, cache locality looks fairly poor because the second inner loop of the three jumps all over the place. Will this implementation beat `Arrays.sort` (for integers)?

#### Benchmark

The algorithm is measured using arrays of random positive integers, for which both algorithms are equivalent, from a range of sizes. This isn't always the best idea (the Tim Sort algorithm comes into its own on nearly sorted data), so take the result below with a pinch of salt. Care must be taken to copy the array in the benchmark since both algorithms are in-place. 

```java
public void launchBenchmark(String... jvmArgs) throws Exception {
        Options opt = new OptionsBuilder()
                .include(this.getClass().getName() + ".*")
                .mode(Mode.SampleTime)
                .mode(Mode.Throughput)
                .timeUnit(TimeUnit.MILLISECONDS)
                .measurementTime(TimeValue.seconds(10))
                .warmupIterations(10)
                .measurementIterations(10)
                .forks(1)
                .shouldFailOnError(true)
                .shouldDoGC(true)
                .jvmArgs(jvmArgs)
                .resultFormat(ResultFormatType.CSV) 
                .build();

        new Runner(opt).run();
    }


    @Benchmark
    public void Arrays_Sort(Data data, Blackhole bh) {
        int[] array = Arrays.copyOf(data.data, data.size);
        Arrays.sort(array);
        bh.consume(array);
    }

    @Benchmark
    public void Radix_Sort(Data data, Blackhole bh) {
        int[] array = Arrays.copyOf(data.data, data.size);
        data.radixSort.sort(array);
        bh.consume(array);
    }


    @State(Scope.Thread)
    public static class Data {

        @Param({"100", "1000", "10000", "100000", "1000000"})
        int size;

        int[] data;
        RadixSort radixSort = new RadixSort();

        @Setup(Level.Trial)
        public void init() {
            data = createArray(size);
        }
    }

    public static int[] createArray(int size) {
        int[] array = new int[size];
        Random random = new Random(0);
        for (int i = 0; i < size; ++i) {
            array[i] = Math.abs(random.nextInt());
        }
        return array;
    }
```

<div class="table-holder">
<table class="table table-bordered table-hover table-condensed">
<thead>
<th>Benchmark</th>
<th>Mode</th>
<th>Threads</th>
<th>Samples</th>
<th>Score</th>
<th>Score Error (99.9%)</th>
<th>Unit</th>
<th>Param: size</th>
</thead>
<tbody>
<tr>
<td>Arrays_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>1304.687189</td>
<td>147.380334</td>
<td>ops/ms</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>78.518664</td>
<td>9.339994</td>
<td>ops/ms</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>1.700208</td>
<td>0.091836</td>
<td>ops/ms</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>0.133835</td>
<td>0.007146</td>
<td>ops/ms</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>0.010560</td>
<td>0.000409</td>
<td>ops/ms</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>404.807772</td>
<td>24.930898</td>
<td>ops/ms</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>51.787409</td>
<td>4.881181</td>
<td>ops/ms</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>6.065590</td>
<td>0.576709</td>
<td>ops/ms</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>0.620338</td>
<td>0.068776</td>
<td>ops/ms</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>thrpt</td>
<td>1</td>
<td>10</td>
<td>0.043098</td>
<td>0.004481</td>
<td>ops/ms</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>sample</td>
<td>1</td>
<td>3088586</td>
<td>0.000902</td>
<td>0.000018</td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.000394</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.000790</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.000791</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.001186</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.001974</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.020128</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.084096</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>4.096000</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>sample</td>
<td>1</td>
<td>2127794</td>
<td>0.011876</td>
<td>0.000037</td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.007896</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.009872</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.015408</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.024096</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.033920</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.061568</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.894976</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>4.448256</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>sample</td>
<td>1</td>
<td>168991</td>
<td>0.591169</td>
<td>0.001671</td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.483840</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.563200</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.707584</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.766976</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.942080</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>2.058273</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>7.526102</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>46.333952</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>sample</td>
<td>1</td>
<td>13027</td>
<td>7.670135</td>
<td>0.021512</td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>6.356992</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>7.634944</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>8.454144</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>8.742502</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>9.666560</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>12.916883</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>28.037900</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>28.573696</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Arrays_Sort</td>
<td>sample</td>
<td>1</td>
<td>1042</td>
<td>96.278673</td>
<td>0.603645</td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>86.114304</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>94.896128</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>104.293990</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>106.430464</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>111.223767</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>134.172770</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>134.742016</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Arrays_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>134.742016</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>sample</td>
<td>1</td>
<td>2240042</td>
<td>0.002941</td>
<td>0.000033</td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.001578</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.002368</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.003556</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.004344</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.011056</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.027232</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.731127</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>5.660672</td>
<td></td>
<td>ms/op</td>
<td>100</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>sample</td>
<td>1</td>
<td>2695825</td>
<td>0.018553</td>
<td>0.000038</td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.013424</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.016576</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.025280</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.031200</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.050944</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.082944</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.830295</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>6.660096</td>
<td></td>
<td>ms/op</td>
<td>1000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>sample</td>
<td>1</td>
<td>685589</td>
<td>0.145695</td>
<td>0.000234</td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.112512</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.128000</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.196608</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.225792</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.309248</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>0.805888</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>1.818141</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>14.401536</td>
<td></td>
<td>ms/op</td>
<td>10000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>sample</td>
<td>1</td>
<td>60843</td>
<td>1.641961</td>
<td>0.005783</td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>1.251328</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>1.542144</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>2.002944</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>2.375680</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>3.447030</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>5.719294</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>8.724165</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>13.074432</td>
<td></td>
<td>ms/op</td>
<td>100000</td>
</tr>
<tr>
<td>Radix_Sort</td>
<td>sample</td>
<td>1</td>
<td>4846</td>
<td>20.640787</td>
<td>0.260926</td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p0.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>14.893056</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p0.50</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>18.743296</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p0.90</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>26.673152</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p0.95</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>30.724915</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p0.99</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>40.470446</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p0.999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>63.016600</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p0.9999</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>136.052736</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
<tr>
<td>Radix_Sort·p1.00</td>
<td>sample</td>
<td>1</td>
<td>1</td>
<td>136.052736</td>
<td></td>
<td>ms/op</td>
<td>1000000</td>
</tr>
</tbody></table>
</div>

The table tells an interesting story. `Arrays.sort` is vastly superior for small arrays (the arrays most people have), but for large arrays the custom implementation comes into its own. Interestingly, this is consistent with the computer science. If you need to sort large arrays of (unsigned) integers and care about performance, think about implementing radix sort.

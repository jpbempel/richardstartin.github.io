---
title: "Don't Fear the Builder"
author: Richard Startin
post_excerpt: ""
layout: default
redirect_from:
  - /dont-fear-the-builder/
published: true
date: 2017-12-12 16:50:44
---
Writing a nontrivial piece of code requires a programmer to make countless tiny decisions, and to produce good quality code quickly, many of these decisions must be made subconciously. But what happens if your instinct is mostly superstitious bullshit? I instinctively avoid allocating objects when I don't have to, so would not voluntarily resort to using things like `EqualsBuilder` or `HashCodeBuilder` from Apache Commons. I feel dismayed whenever I am asked about the relationship between hash code and equals in interviews for contracts. This indicates a lack of mutual respect, but what's revealing is that enough people passing themselves off as developers don't know this stuff that it makes the question worth asking. `EqualsBuilder` and `HashCodeBuilder` make it so you don't actually need to know, making it safe to put any object in a `HashSet`, whoever wrote the class. But should you use these classes just because they protect the naive (and you from the naive)? Is it a runtime tax? Or is any perceived cost magically eradicated by the JVM? It's time to benchmark my instinct.

<h3>Baseline</h3>

There are definitely no allocations in the code IntelliJ (or similar) would generate for `equals` and `hashCode` automatically. I will use this generated code as the baseline: if I can match or beat this code with `EqualsBuilder` or `HashCodeBuilder` respectively, I can dismiss my prejudice. Here's the baseline class:

```java
public class Baseline {
    
    private final String a;
    private final int b;
    private final String c;
    private final Instant d;

    public Baseline(String a, int b, String c, Instant d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Baseline baseline = (Baseline) o;

        if (b != baseline.b) return false;
        if (!a.equals(baseline.a)) return false;
        if (!c.equals(baseline.c)) return false;
        return d.equals(baseline.d);
    }

    @Override
    public int hashCode() {
        int result = a.hashCode();
        result = 31 * result + b;
        result = 31 * result + c.hashCode();
        result = 31 * result + d.hashCode();
        return result;
    }
}
```

It's not pretty and it's a real pain to keep generated code up to date when adding and removing fields (you can delete it and regenerate it but it creates merge noise) but there's no obvious way to improve on this code. It's correct and looks fast. To benchmark alternatives, I want to look at the effect on set membership queries against a `HashSet` of various sizes.

<h3>Builder Implementation</h3>

I will contrast this with the following code using code from Apache Commons (incidentally, also generated by IntelliJ):

```java
public class Builder {

    private final String a;
    private final int b;
    private final String c;
    private final Instant d;

    public Builder(String a, int b, String c, Instant d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;

        if (o == null || getClass() != o.getClass()) return false;

        Builder builder = (Builder) o;

        return new EqualsBuilder()
                .append(b, builder.b)
                .append(a, builder.a)
                .append(c, builder.c)
                .append(d, builder.d)
                .isEquals();
    }

    @Override
    public int hashCode() {
        return new HashCodeBuilder(17, 37)
                .append(a)
                .append(b)
                .append(c)
                .append(d)
                .toHashCode();
    }
}
```

This code is a bit neater and easier to maintain, but does it have an observable cost?

<h3>HashSet Benchmark</h3>

For a parametrised range of `HashSet` sizes, I measure throughput for calls to `contains`. This requires that both `hashCode` and `equals` are called, the latter potentially several times. There is bias in this benchmark, because the implementation producing the best hash function will minimise the calls to `equals`, but I am willing to reward the better implementation rather than maniacally isolate any attributable allocation cost.

The code is simple, if a little repetitive. For each implementation, I make some random instances of my class, and make one that I can be sure isn't in the set. I measure the cost of repeated invocations to the `hashCode` and `equals` methods by finding an object, and searching but failing to find an object separately.

```java
@State(Scope.Benchmark)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public class HashSetContainsBenchmark {

    @Param({"8", "96", "1024", "8192"})
    int setSize;

    private HashSet<Baseline> baselineSet;
    private Baseline presentBaseline;
    private Baseline missingBaseline;

    private HashSet<Builder> builderSet;
    private Builder presentBuilder;
    private Builder missingBuilder;

    @Setup(Level.Trial)
    public void setup() {
        setupBaselineState();
        setupBuilderState();
    }

    private void setupBaselineState() {
        baselineSet = new HashSet<>();
        for (int i = 0; i < setSize; ++i) {
            while(!baselineSet.add(newBaselineInstance()));
        }
        presentBaseline = baselineSet.iterator().next();
        do {
            missingBaseline = newBaselineInstance();
        } while (baselineSet.contains(missingBaseline));
    }

    private void setupBuilderState() {
        builderSet = new HashSet<>();
        for (int i = 0; i < setSize; ++i) {
            while(!builderSet.add(newBuilderInstance()));
        }
        presentBuilder = builderSet.iterator().next();
        do {
            missingBuilder = newBuilderInstance();
        } while (builderSet.contains(missingBuilder));
    }

    @Benchmark
    public boolean findPresentBaselineInstance() {
        return baselineSet.contains(presentBaseline);
    }

    @Benchmark
    public boolean findMissingBaselineInstance() {
        return baselineSet.contains(missingBaseline);
    }

    @Benchmark
    public boolean findPresentBuilderInstance() {
        return builderSet.contains(presentBuilder);
    }

    @Benchmark
    public boolean findMissingBuilderInstance() {
        return builderSet.contains(missingBuilder);
    }


    private static Baseline newBaselineInstance() {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        return new Baseline(UUID.randomUUID().toString(),
                random.nextInt(),
                UUID.randomUUID().toString(),
                Instant.ofEpochMilli(random.nextLong(0, Instant.now().toEpochMilli())));
    }

    private static Builder newBuilderInstance() {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        return new Builder(UUID.randomUUID().toString(),
                random.nextInt(),
                UUID.randomUUID().toString(),
                Instant.ofEpochMilli(random.nextLong(0, Instant.now().toEpochMilli())));
    }
}
```

Running this benchmark with `org.apache.commons:commons-lang3:3.7` yields the throughput results below. There is an occasional and slight throughput degradation with the builders, but the builder implementation is sometimes faster in this benchmark, but the difference isn't large enough to worry about.

<div class="table-holder">
<table class="table table-bordered table-hover table-condensed">
<thead><tr><th>Benchmark</th>
<th>Mode</th>
<th>Threads</th>
<th>Samples</th>
<th>Score</th>
<th>Score Error (99.9%)</th>
<th>Unit</th>
<th>Param: setSize</th>
</tr></thead>
<tbody><tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">153.878772</td>
<td align="right">7.993036</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">135.835085</td>
<td align="right">6.031588</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">137.716073</td>
<td align="right">25.731562</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">123.896741</td>
<td align="right">15.484023</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">142.051528</td>
<td align="right">4.177352</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">132.326909</td>
<td align="right">1.017351</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">127.220440</td>
<td align="right">8.680761</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">140.029701</td>
<td align="right">6.272960</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">139.714236</td>
<td align="right">1.626873</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">140.244864</td>
<td align="right">1.777298</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">135.273760</td>
<td align="right">7.587937</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">133.158555</td>
<td align="right">5.101069</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">111.196443</td>
<td align="right">18.804103</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">124.008441</td>
<td align="right">5.182294</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">126.729750</td>
<td align="right">4.286002</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">124.159285</td>
<td align="right">5.287920</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
</tbody></table>
</div>

<h3>Where did the builder go?</h3>

It's worth taking a look at the compiler output to find out what happened. Considering the case where the object isn't found in the set, we can see that the code gets inlined, and the hash code must be quite good. By enabling the args `-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining` it's clear to see that the entire hash code generation gets inlined into the calling loop, and that equals is never executed (suggesting that there are no collisions to resolve here) .

```
                              @ 8   java.util.HashSet::contains (9 bytes)   inline (hot)
                                @ 5   java.util.HashMap::containsKey (18 bytes)   inline (hot)
                                 \-> TypeProfile (17571/17571 counts) = java/util/HashMap
                                  @ 2   java.util.HashMap::hash (20 bytes)   inline (hot)
                                    @ 9   com.openkappa.simd.builder.Builder::hashCode (43 bytes)   inline (hot)
                                      @ 8   org.apache.commons.lang3.builder.HashCodeBuilder::<init> (60 bytes)   inline (hot)
                                        @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)
                                        @ 26   org.apache.commons.lang3.Validate::isTrue (18 bytes)   unloaded signature classes
                                        @ 46   org.apache.commons.lang3.Validate::isTrue (18 bytes)   unloaded signature classes
                                      @ 15   org.apache.commons.lang3.builder.HashCodeBuilder::append (58 bytes)   inline (hot)
                                        @ 21   java.lang.Object::getClass (0 bytes)   (intrinsic)
                                        @ 24   java.lang.Class::isArray (0 bytes)   (intrinsic)
                                        @ 49   java.lang.String::hashCode (49 bytes)   inline (hot)
                                          @ 19   java.lang.String::isLatin1 (19 bytes)   inline (hot)
                                          @ 29   java.lang.StringLatin1::hashCode (42 bytes)   inline (hot)
                                      @ 22   org.apache.commons.lang3.builder.HashCodeBuilder::append (17 bytes)   inline (hot)
                                      @ 29   org.apache.commons.lang3.builder.HashCodeBuilder::append (58 bytes)   inline (hot)
                                        @ 21   java.lang.Object::getClass (0 bytes)   (intrinsic)
                                        @ 24   java.lang.Class::isArray (0 bytes)   (intrinsic)
                                        @ 49   java.lang.String::hashCode (49 bytes)   inline (hot)
                                          @ 19   java.lang.String::isLatin1 (19 bytes)   inline (hot)
                                          @ 29   java.lang.StringLatin1::hashCode (42 bytes)   inline (hot)
                                      @ 36   org.apache.commons.lang3.builder.HashCodeBuilder::append (58 bytes)   inline (hot)
                                        @ 21   java.lang.Object::getClass (0 bytes)   (intrinsic)
                                        @ 24   java.lang.Class::isArray (0 bytes)   (intrinsic)
                                        @ 49   java.time.Instant::hashCode (22 bytes)   inline (hot)
                                      @ 39   org.apache.commons.lang3.builder.HashCodeBuilder::toHashCode (5 bytes)   accessor
                                  @ 6   java.util.HashMap::getNode (148 bytes)   inline (hot)
                                    @ 59   com.openkappa.simd.builder.Builder::equals (84 bytes)   never executed
                                    @ 126   com.openkappa.simd.builder.Builder::equals (84 bytes)   never executed
```

So the code is clearly small enough to get inlined. But what about the builder itself, isn't it allocated? Not if it doesn't escape. On a debug JVM, it's possible to observe the removal of the builder's allocation the JVM args `-XX:+PrintEscapeAnalysis -XX:+PrintEliminateAllocations`. However, on a production JVM, it can be observed indirectly by measuring the difference when escape analysis is disabled with `-XX:-DoEscapeAnalysis`.

<div class="table-holder">
<table class="table table-bordered table-hover table-condensed">
<thead><tr><th>Benchmark</th>
<th>Mode</th>
<th>Threads</th>
<th>Samples</th>
<th>Score</th>
<th>Score Error (99.9%)</th>
<th>Unit</th>
<th>Param: setSize</th>
</tr></thead>
<tbody><tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">150.972758</td>
<td align="right">5.095163</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">140.236057</td>
<td align="right">2.222751</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">132.680494</td>
<td align="right">5.225503</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findMissingBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">115.220385</td>
<td align="right">4.232488</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">68.869355</td>
<td align="right">4.479944</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">67.786351</td>
<td align="right">5.980353</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">71.113062</td>
<td align="right">3.057181</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findMissingBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">75.088839</td>
<td align="right">1.592294</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">141.425675</td>
<td align="right">2.630898</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">142.636359</td>
<td align="right">2.854795</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">143.939199</td>
<td align="right">0.475918</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findPresentBaselineInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">142.006635</td>
<td align="right">3.098352</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">71.546971</td>
<td align="right">6.152584</td>
<td>ops/us</td>
<td align="right">8</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">62.451705</td>
<td align="right">11.896730</td>
<td>ops/us</td>
<td align="right">96</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">68.903442</td>
<td align="right">3.263955</td>
<td>ops/us</td>
<td align="right">1024</td>
</tr>
<tr>
<td>findPresentBuilderInstance</td>
<td>thrpt</td>
<td>1</td>
<td align="right">10</td>
<td align="right">69.576038</td>
<td align="right">4.047581</td>
<td>ops/us</td>
<td align="right">8192</td>
</tr>
</tbody></table>
</div>

Without escape analysis, the baseline code hardly slows down, whereas the change in the builder benchmarks is stark. The difference of differences here isolates the cost of allocating the `HashCodeBuilder` on the heap, though the builder has <em>not</em> been allocated on the stack - it has been replaced by its fields, which <em>are</em> allocated on the stack. Escape analysis is enabled by default, and the key point here is that even if the code <em>looks</em> like it might be slower, it might be as good or better - it depends what the JIT does with it.